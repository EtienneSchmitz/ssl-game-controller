// @ts-nocheck
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 3.15.8
 * source: ssl_gc_engine.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./ssl_gc_geometry";
import * as dependency_2 from "./ssl_gc_common";
import * as dependency_3 from "./google/protobuf/timestamp";
import * as pb_1 from "google-protobuf";
export class GcState extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        teamState: Map<string, GcStateTeam>;
        autoRefState: Map<string, GcStateAutoRef>;
        trackers: Map<string, string>;
        continueActions: ContinueAction[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [4], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.teamState = data.teamState;
            this.autoRefState = data.autoRefState;
            this.trackers = data.trackers;
            this.continueActions = data.continueActions;
        }
        if (!this.teamState)
            this.teamState = new Map();
        if (!this.autoRefState)
            this.autoRefState = new Map();
        if (!this.trackers)
            this.trackers = new Map();
    }
    get teamState() {
        return pb_1.Message.getField(this, 1) as any as Map<string, GcStateTeam>;
    }
    set teamState(value: Map<string, GcStateTeam>) {
        pb_1.Message.setField(this, 1, value as any);
    }
    get autoRefState() {
        return pb_1.Message.getField(this, 2) as any as Map<string, GcStateAutoRef>;
    }
    set autoRefState(value: Map<string, GcStateAutoRef>) {
        pb_1.Message.setField(this, 2, value as any);
    }
    get trackers() {
        return pb_1.Message.getField(this, 3) as any as Map<string, string>;
    }
    set trackers(value: Map<string, string>) {
        pb_1.Message.setField(this, 3, value as any);
    }
    get continueActions() {
        return pb_1.Message.getRepeatedWrapperField(this, ContinueAction, 4) as ContinueAction[];
    }
    set continueActions(value: ContinueAction[]) {
        pb_1.Message.setRepeatedWrapperField(this, 4, value);
    }
    static fromObject(data: {
        teamState?: {
            [key: string]: ReturnType<typeof GcStateTeam.prototype.toObject>;
        };
        autoRefState?: {
            [key: string]: ReturnType<typeof GcStateAutoRef.prototype.toObject>;
        };
        trackers?: {
            [key: string]: string;
        };
        continueActions?: ReturnType<typeof ContinueAction.prototype.toObject>[];
    }): GcState {
        const message = new GcState({
            teamState: new Map(Object.entries(data.teamState).map(([key, value]) => [key, GcStateTeam.fromObject(value)])),
            autoRefState: new Map(Object.entries(data.autoRefState).map(([key, value]) => [key, GcStateAutoRef.fromObject(value)])),
            trackers: new Map(Object.entries(data.trackers)),
            continueActions: data.continueActions.map(item => ContinueAction.fromObject(item))
        });
        return message;
    }
    toObject() {
        const data: {
            teamState?: {
                [key: string]: ReturnType<typeof GcStateTeam.prototype.toObject>;
            };
            autoRefState?: {
                [key: string]: ReturnType<typeof GcStateAutoRef.prototype.toObject>;
            };
            trackers?: {
                [key: string]: string;
            };
            continueActions?: ReturnType<typeof ContinueAction.prototype.toObject>[];
        } = {};
        if (this.teamState.size > 0) {
            data.teamState = Object.fromEntries(Array.from(this.teamState).map(([key, value]) => [key, value.toObject()]));
        }
        if (this.autoRefState.size > 0) {
            data.autoRefState = Object.fromEntries(Array.from(this.autoRefState).map(([key, value]) => [key, value.toObject()]));
        }
        if (this.trackers.size > 0) {
            data.trackers = Object.fromEntries(this.trackers);
        }
        if (this.continueActions != null) {
            data.continueActions = this.continueActions.map((item: ContinueAction) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        for (const [key, value] of this.teamState) {
            writer.writeMessage(1, this.teamState, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        for (const [key, value] of this.autoRefState) {
            writer.writeMessage(2, this.autoRefState, () => {
                writer.writeString(1, key);
                writer.writeMessage(2, value, () => value.serialize(writer));
            });
        }
        for (const [key, value] of this.trackers) {
            writer.writeMessage(3, this.trackers, () => {
                writer.writeString(1, key);
                writer.writeString(2, value);
            });
        }
        if (this.continueActions.length)
            writer.writeRepeatedMessage(4, this.continueActions, (item: ContinueAction) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GcState {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GcState();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.teamState as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = GcStateTeam.deserialize(reader));
                        return value;
                    }));
                    break;
                case 2:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.autoRefState as any, reader, reader.readString, () => {
                        let value;
                        reader.readMessage(message, () => value = GcStateAutoRef.deserialize(reader));
                        return value;
                    }));
                    break;
                case 3:
                    reader.readMessage(message, () => pb_1.Map.deserializeBinary(message.trackers as any, reader, reader.readString, reader.readString));
                    break;
                case 4:
                    reader.readMessage(message.continueActions, () => pb_1.Message.addToRepeatedWrapperField(message, 4, ContinueAction.deserialize(reader), ContinueAction));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GcState {
        return GcState.deserialize(bytes);
    }
}
export class GcStateTeam extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        connected?: boolean;
        connectionVerified?: boolean;
        remoteControlConnected?: boolean;
        remoteControlConnectionVerified?: boolean;
        advantageChoice?: TeamAdvantageChoice;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("connected" in data && data.connected != undefined) {
                this.connected = data.connected;
            }
            if ("connectionVerified" in data && data.connectionVerified != undefined) {
                this.connectionVerified = data.connectionVerified;
            }
            if ("remoteControlConnected" in data && data.remoteControlConnected != undefined) {
                this.remoteControlConnected = data.remoteControlConnected;
            }
            if ("remoteControlConnectionVerified" in data && data.remoteControlConnectionVerified != undefined) {
                this.remoteControlConnectionVerified = data.remoteControlConnectionVerified;
            }
            if ("advantageChoice" in data && data.advantageChoice != undefined) {
                this.advantageChoice = data.advantageChoice;
            }
        }
    }
    get connected() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set connected(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasConnected() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get connectionVerified() {
        return pb_1.Message.getFieldWithDefault(this, 2, false) as boolean;
    }
    set connectionVerified(value: boolean) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasConnectionVerified() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get remoteControlConnected() {
        return pb_1.Message.getFieldWithDefault(this, 3, false) as boolean;
    }
    set remoteControlConnected(value: boolean) {
        pb_1.Message.setField(this, 3, value);
    }
    get hasRemoteControlConnected() {
        return pb_1.Message.getField(this, 3) != null;
    }
    get remoteControlConnectionVerified() {
        return pb_1.Message.getFieldWithDefault(this, 4, false) as boolean;
    }
    set remoteControlConnectionVerified(value: boolean) {
        pb_1.Message.setField(this, 4, value);
    }
    get hasRemoteControlConnectionVerified() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get advantageChoice() {
        return pb_1.Message.getWrapperField(this, TeamAdvantageChoice, 5) as TeamAdvantageChoice;
    }
    set advantageChoice(value: TeamAdvantageChoice) {
        pb_1.Message.setWrapperField(this, 5, value);
    }
    get hasAdvantageChoice() {
        return pb_1.Message.getField(this, 5) != null;
    }
    static fromObject(data: {
        connected?: boolean;
        connectionVerified?: boolean;
        remoteControlConnected?: boolean;
        remoteControlConnectionVerified?: boolean;
        advantageChoice?: ReturnType<typeof TeamAdvantageChoice.prototype.toObject>;
    }): GcStateTeam {
        const message = new GcStateTeam({});
        if (data.connected != null) {
            message.connected = data.connected;
        }
        if (data.connectionVerified != null) {
            message.connectionVerified = data.connectionVerified;
        }
        if (data.remoteControlConnected != null) {
            message.remoteControlConnected = data.remoteControlConnected;
        }
        if (data.remoteControlConnectionVerified != null) {
            message.remoteControlConnectionVerified = data.remoteControlConnectionVerified;
        }
        if (data.advantageChoice != null) {
            message.advantageChoice = TeamAdvantageChoice.fromObject(data.advantageChoice);
        }
        return message;
    }
    toObject() {
        const data: {
            connected?: boolean;
            connectionVerified?: boolean;
            remoteControlConnected?: boolean;
            remoteControlConnectionVerified?: boolean;
            advantageChoice?: ReturnType<typeof TeamAdvantageChoice.prototype.toObject>;
        } = {};
        if (this.connected != null) {
            data.connected = this.connected;
        }
        if (this.connectionVerified != null) {
            data.connectionVerified = this.connectionVerified;
        }
        if (this.remoteControlConnected != null) {
            data.remoteControlConnected = this.remoteControlConnected;
        }
        if (this.remoteControlConnectionVerified != null) {
            data.remoteControlConnectionVerified = this.remoteControlConnectionVerified;
        }
        if (this.advantageChoice != null) {
            data.advantageChoice = this.advantageChoice.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasConnected)
            writer.writeBool(1, this.connected);
        if (this.hasConnectionVerified)
            writer.writeBool(2, this.connectionVerified);
        if (this.hasRemoteControlConnected)
            writer.writeBool(3, this.remoteControlConnected);
        if (this.hasRemoteControlConnectionVerified)
            writer.writeBool(4, this.remoteControlConnectionVerified);
        if (this.hasAdvantageChoice)
            writer.writeMessage(5, this.advantageChoice, () => this.advantageChoice.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GcStateTeam {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GcStateTeam();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.connected = reader.readBool();
                    break;
                case 2:
                    message.connectionVerified = reader.readBool();
                    break;
                case 3:
                    message.remoteControlConnected = reader.readBool();
                    break;
                case 4:
                    message.remoteControlConnectionVerified = reader.readBool();
                    break;
                case 5:
                    reader.readMessage(message.advantageChoice, () => message.advantageChoice = TeamAdvantageChoice.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GcStateTeam {
        return GcStateTeam.deserialize(bytes);
    }
}
export class TeamAdvantageChoice extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        choice?: TeamAdvantageChoice.AdvantageChoice;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("choice" in data && data.choice != undefined) {
                this.choice = data.choice;
            }
        }
    }
    get choice() {
        return pb_1.Message.getFieldWithDefault(this, 1, TeamAdvantageChoice.AdvantageChoice.STOP) as TeamAdvantageChoice.AdvantageChoice;
    }
    set choice(value: TeamAdvantageChoice.AdvantageChoice) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasChoice() {
        return pb_1.Message.getField(this, 1) != null;
    }
    static fromObject(data: {
        choice?: TeamAdvantageChoice.AdvantageChoice;
    }): TeamAdvantageChoice {
        const message = new TeamAdvantageChoice({});
        if (data.choice != null) {
            message.choice = data.choice;
        }
        return message;
    }
    toObject() {
        const data: {
            choice?: TeamAdvantageChoice.AdvantageChoice;
        } = {};
        if (this.choice != null) {
            data.choice = this.choice;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasChoice)
            writer.writeEnum(1, this.choice);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): TeamAdvantageChoice {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new TeamAdvantageChoice();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.choice = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): TeamAdvantageChoice {
        return TeamAdvantageChoice.deserialize(bytes);
    }
}
export namespace TeamAdvantageChoice {
    export enum AdvantageChoice {
        STOP = 0,
        CONTINUE = 1
    }
}
export class GcStateAutoRef extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        connectionVerified?: boolean;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("connectionVerified" in data && data.connectionVerified != undefined) {
                this.connectionVerified = data.connectionVerified;
            }
        }
    }
    get connectionVerified() {
        return pb_1.Message.getFieldWithDefault(this, 1, false) as boolean;
    }
    set connectionVerified(value: boolean) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasConnectionVerified() {
        return pb_1.Message.getField(this, 1) != null;
    }
    static fromObject(data: {
        connectionVerified?: boolean;
    }): GcStateAutoRef {
        const message = new GcStateAutoRef({});
        if (data.connectionVerified != null) {
            message.connectionVerified = data.connectionVerified;
        }
        return message;
    }
    toObject() {
        const data: {
            connectionVerified?: boolean;
        } = {};
        if (this.connectionVerified != null) {
            data.connectionVerified = this.connectionVerified;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasConnectionVerified)
            writer.writeBool(1, this.connectionVerified);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GcStateAutoRef {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GcStateAutoRef();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.connectionVerified = reader.readBool();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GcStateAutoRef {
        return GcStateAutoRef.deserialize(bytes);
    }
}
export class GcStateTracker extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        sourceName?: string;
        uuid?: string;
        ball?: Ball;
        robots: Robot[];
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("sourceName" in data && data.sourceName != undefined) {
                this.sourceName = data.sourceName;
            }
            if ("uuid" in data && data.uuid != undefined) {
                this.uuid = data.uuid;
            }
            if ("ball" in data && data.ball != undefined) {
                this.ball = data.ball;
            }
            this.robots = data.robots;
        }
    }
    get sourceName() {
        return pb_1.Message.getFieldWithDefault(this, 1, "") as string;
    }
    set sourceName(value: string) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasSourceName() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get uuid() {
        return pb_1.Message.getFieldWithDefault(this, 4, "") as string;
    }
    set uuid(value: string) {
        pb_1.Message.setField(this, 4, value);
    }
    get hasUuid() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get ball() {
        return pb_1.Message.getWrapperField(this, Ball, 2) as Ball;
    }
    set ball(value: Ball) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get hasBall() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get robots() {
        return pb_1.Message.getRepeatedWrapperField(this, Robot, 3) as Robot[];
    }
    set robots(value: Robot[]) {
        pb_1.Message.setRepeatedWrapperField(this, 3, value);
    }
    static fromObject(data: {
        sourceName?: string;
        uuid?: string;
        ball?: ReturnType<typeof Ball.prototype.toObject>;
        robots?: ReturnType<typeof Robot.prototype.toObject>[];
    }): GcStateTracker {
        const message = new GcStateTracker({
            robots: data.robots.map(item => Robot.fromObject(item))
        });
        if (data.sourceName != null) {
            message.sourceName = data.sourceName;
        }
        if (data.uuid != null) {
            message.uuid = data.uuid;
        }
        if (data.ball != null) {
            message.ball = Ball.fromObject(data.ball);
        }
        return message;
    }
    toObject() {
        const data: {
            sourceName?: string;
            uuid?: string;
            ball?: ReturnType<typeof Ball.prototype.toObject>;
            robots?: ReturnType<typeof Robot.prototype.toObject>[];
        } = {};
        if (this.sourceName != null) {
            data.sourceName = this.sourceName;
        }
        if (this.uuid != null) {
            data.uuid = this.uuid;
        }
        if (this.ball != null) {
            data.ball = this.ball.toObject();
        }
        if (this.robots != null) {
            data.robots = this.robots.map((item: Robot) => item.toObject());
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasSourceName && this.sourceName.length)
            writer.writeString(1, this.sourceName);
        if (this.hasUuid && this.uuid.length)
            writer.writeString(4, this.uuid);
        if (this.hasBall)
            writer.writeMessage(2, this.ball, () => this.ball.serialize(writer));
        if (this.robots.length)
            writer.writeRepeatedMessage(3, this.robots, (item: Robot) => item.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): GcStateTracker {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new GcStateTracker();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.sourceName = reader.readString();
                    break;
                case 4:
                    message.uuid = reader.readString();
                    break;
                case 2:
                    reader.readMessage(message.ball, () => message.ball = Ball.deserialize(reader));
                    break;
                case 3:
                    reader.readMessage(message.robots, () => pb_1.Message.addToRepeatedWrapperField(message, 3, Robot.deserialize(reader), Robot));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): GcStateTracker {
        return GcStateTracker.deserialize(bytes);
    }
}
export class Ball extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        pos?: dependency_1.Vector3;
        vel?: dependency_1.Vector3;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("pos" in data && data.pos != undefined) {
                this.pos = data.pos;
            }
            if ("vel" in data && data.vel != undefined) {
                this.vel = data.vel;
            }
        }
    }
    get pos() {
        return pb_1.Message.getWrapperField(this, dependency_1.Vector3, 1) as dependency_1.Vector3;
    }
    set pos(value: dependency_1.Vector3) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get hasPos() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get vel() {
        return pb_1.Message.getWrapperField(this, dependency_1.Vector3, 2) as dependency_1.Vector3;
    }
    set vel(value: dependency_1.Vector3) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get hasVel() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        pos?: ReturnType<typeof dependency_1.Vector3.prototype.toObject>;
        vel?: ReturnType<typeof dependency_1.Vector3.prototype.toObject>;
    }): Ball {
        const message = new Ball({});
        if (data.pos != null) {
            message.pos = dependency_1.Vector3.fromObject(data.pos);
        }
        if (data.vel != null) {
            message.vel = dependency_1.Vector3.fromObject(data.vel);
        }
        return message;
    }
    toObject() {
        const data: {
            pos?: ReturnType<typeof dependency_1.Vector3.prototype.toObject>;
            vel?: ReturnType<typeof dependency_1.Vector3.prototype.toObject>;
        } = {};
        if (this.pos != null) {
            data.pos = this.pos.toObject();
        }
        if (this.vel != null) {
            data.vel = this.vel.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasPos)
            writer.writeMessage(1, this.pos, () => this.pos.serialize(writer));
        if (this.hasVel)
            writer.writeMessage(2, this.vel, () => this.vel.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Ball {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Ball();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.pos, () => message.pos = dependency_1.Vector3.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.vel, () => message.vel = dependency_1.Vector3.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Ball {
        return Ball.deserialize(bytes);
    }
}
export class Robot extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        id?: dependency_2.RobotId;
        pos?: dependency_1.Vector2;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            if ("id" in data && data.id != undefined) {
                this.id = data.id;
            }
            if ("pos" in data && data.pos != undefined) {
                this.pos = data.pos;
            }
        }
    }
    get id() {
        return pb_1.Message.getWrapperField(this, dependency_2.RobotId, 1) as dependency_2.RobotId;
    }
    set id(value: dependency_2.RobotId) {
        pb_1.Message.setWrapperField(this, 1, value);
    }
    get hasId() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get pos() {
        return pb_1.Message.getWrapperField(this, dependency_1.Vector2, 2) as dependency_1.Vector2;
    }
    set pos(value: dependency_1.Vector2) {
        pb_1.Message.setWrapperField(this, 2, value);
    }
    get hasPos() {
        return pb_1.Message.getField(this, 2) != null;
    }
    static fromObject(data: {
        id?: ReturnType<typeof dependency_2.RobotId.prototype.toObject>;
        pos?: ReturnType<typeof dependency_1.Vector2.prototype.toObject>;
    }): Robot {
        const message = new Robot({});
        if (data.id != null) {
            message.id = dependency_2.RobotId.fromObject(data.id);
        }
        if (data.pos != null) {
            message.pos = dependency_1.Vector2.fromObject(data.pos);
        }
        return message;
    }
    toObject() {
        const data: {
            id?: ReturnType<typeof dependency_2.RobotId.prototype.toObject>;
            pos?: ReturnType<typeof dependency_1.Vector2.prototype.toObject>;
        } = {};
        if (this.id != null) {
            data.id = this.id.toObject();
        }
        if (this.pos != null) {
            data.pos = this.pos.toObject();
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasId)
            writer.writeMessage(1, this.id, () => this.id.serialize(writer));
        if (this.hasPos)
            writer.writeMessage(2, this.pos, () => this.pos.serialize(writer));
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): Robot {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new Robot();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    reader.readMessage(message.id, () => message.id = dependency_2.RobotId.deserialize(reader));
                    break;
                case 2:
                    reader.readMessage(message.pos, () => message.pos = dependency_1.Vector2.deserialize(reader));
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): Robot {
        return Robot.deserialize(bytes);
    }
}
export class ContinueAction extends pb_1.Message {
    #one_of_decls: number[][] = [];
    constructor(data?: any[] | {
        type: ContinueAction.Type;
        forTeam: dependency_2.Team;
        continuationIssues: string[];
        readyAt?: dependency_3.google.protobuf.Timestamp;
        state?: ContinueAction.State;
    }) {
        super();
        pb_1.Message.initialize(this, Array.isArray(data) ? data : [], 0, -1, [3], this.#one_of_decls);
        if (!Array.isArray(data) && typeof data == "object") {
            this.type = data.type;
            this.forTeam = data.forTeam;
            this.continuationIssues = data.continuationIssues;
            if ("readyAt" in data && data.readyAt != undefined) {
                this.readyAt = data.readyAt;
            }
            if ("state" in data && data.state != undefined) {
                this.state = data.state;
            }
        }
    }
    get type() {
        return pb_1.Message.getField(this, 1) as ContinueAction.Type;
    }
    set type(value: ContinueAction.Type) {
        pb_1.Message.setField(this, 1, value);
    }
    get hasType() {
        return pb_1.Message.getField(this, 1) != null;
    }
    get forTeam() {
        return pb_1.Message.getField(this, 2) as dependency_2.Team;
    }
    set forTeam(value: dependency_2.Team) {
        pb_1.Message.setField(this, 2, value);
    }
    get hasForTeam() {
        return pb_1.Message.getField(this, 2) != null;
    }
    get continuationIssues() {
        return pb_1.Message.getFieldWithDefault(this, 3, []) as string[];
    }
    set continuationIssues(value: string[]) {
        pb_1.Message.setField(this, 3, value);
    }
    get readyAt() {
        return pb_1.Message.getWrapperField(this, dependency_3.google.protobuf.Timestamp, 4) as dependency_3.google.protobuf.Timestamp;
    }
    set readyAt(value: dependency_3.google.protobuf.Timestamp) {
        pb_1.Message.setWrapperField(this, 4, value);
    }
    get hasReadyAt() {
        return pb_1.Message.getField(this, 4) != null;
    }
    get state() {
        return pb_1.Message.getFieldWithDefault(this, 5, ContinueAction.State.STATE_UNKNOWN) as ContinueAction.State;
    }
    set state(value: ContinueAction.State) {
        pb_1.Message.setField(this, 5, value);
    }
    get hasState() {
        return pb_1.Message.getField(this, 5) != null;
    }
    static fromObject(data: {
        type?: ContinueAction.Type;
        forTeam?: dependency_2.Team;
        continuationIssues: string[];
        readyAt?: ReturnType<typeof dependency_3.google.protobuf.Timestamp.prototype.toObject>;
        state?: ContinueAction.State;
    }): ContinueAction {
        const message = new ContinueAction({
            type: data.type,
            forTeam: data.forTeam,
            continuationIssues: data.continuationIssues
        });
        if (data.readyAt != null) {
            message.readyAt = dependency_3.google.protobuf.Timestamp.fromObject(data.readyAt);
        }
        if (data.state != null) {
            message.state = data.state;
        }
        return message;
    }
    toObject() {
        const data: {
            type?: ContinueAction.Type;
            forTeam?: dependency_2.Team;
            continuationIssues: string[];
            readyAt?: ReturnType<typeof dependency_3.google.protobuf.Timestamp.prototype.toObject>;
            state?: ContinueAction.State;
        } = {
            continuationIssues: this.continuationIssues
        };
        if (this.type != null) {
            data.type = this.type;
        }
        if (this.forTeam != null) {
            data.forTeam = this.forTeam;
        }
        if (this.readyAt != null) {
            data.readyAt = this.readyAt.toObject();
        }
        if (this.state != null) {
            data.state = this.state;
        }
        return data;
    }
    serialize(): Uint8Array;
    serialize(w: pb_1.BinaryWriter): void;
    serialize(w?: pb_1.BinaryWriter): Uint8Array | void {
        const writer = w || new pb_1.BinaryWriter();
        if (this.hasType)
            writer.writeEnum(1, this.type);
        if (this.hasForTeam)
            writer.writeEnum(2, this.forTeam);
        if (this.continuationIssues.length)
            writer.writeRepeatedString(3, this.continuationIssues);
        if (this.hasReadyAt)
            writer.writeMessage(4, this.readyAt, () => this.readyAt.serialize(writer));
        if (this.hasState)
            writer.writeEnum(5, this.state);
        if (!w)
            return writer.getResultBuffer();
    }
    static deserialize(bytes: Uint8Array | pb_1.BinaryReader): ContinueAction {
        const reader = bytes instanceof pb_1.BinaryReader ? bytes : new pb_1.BinaryReader(bytes), message = new ContinueAction();
        while (reader.nextField()) {
            if (reader.isEndGroup())
                break;
            switch (reader.getFieldNumber()) {
                case 1:
                    message.type = reader.readEnum();
                    break;
                case 2:
                    message.forTeam = reader.readEnum();
                    break;
                case 3:
                    pb_1.Message.addToRepeatedField(message, 3, reader.readString());
                    break;
                case 4:
                    reader.readMessage(message.readyAt, () => message.readyAt = dependency_3.google.protobuf.Timestamp.deserialize(reader));
                    break;
                case 5:
                    message.state = reader.readEnum();
                    break;
                default: reader.skipField();
            }
        }
        return message;
    }
    serializeBinary(): Uint8Array {
        return this.serialize();
    }
    static deserializeBinary(bytes: Uint8Array): ContinueAction {
        return ContinueAction.deserialize(bytes);
    }
}
export namespace ContinueAction {
    export enum Type {
        TYPE_UNKNOWN = 0,
        HALT = 1,
        RESUME_FROM_HALT = 10,
        STOP_GAME = 2,
        RESUME_FROM_STOP = 11,
        NEXT_COMMAND = 3,
        BALL_PLACEMENT_START = 4,
        BALL_PLACEMENT_CANCEL = 9,
        TIMEOUT_START = 5,
        TIMEOUT_STOP = 6,
        BOT_SUBSTITUTION = 7,
        NEXT_STAGE = 8
    }
    export enum State {
        STATE_UNKNOWN = 0,
        BLOCKED = 1,
        WAITING = 2,
        READY_AUTO = 3,
        READY_MANUAL = 4
    }
}
